// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPost = `-- name: CreatePost :one
INSERT INTO post (user_id, title, content) 
VALUES ($1, $2, $3) 
RETURNING id, user_id, title, content, created_at, updated_at
`

type CreatePostParams struct {
	UserID  int32
	Title   string
	Content string
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost, arg.UserID, arg.Title, arg.Content)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tag (name)
VALUES ($1)
RETURNING id, name, created_at, updated_at
`

func (q *Queries) CreateTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, createTag, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
    user_info (
        email,
        username,
        first_name,
        last_name,
        role,
        password
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        encode(digest($6, 'sha256'), 'hex')
    )
RETURNING
    id, email, username, first_name, last_name, role, password, created_at, updated_at
`

type CreateUserParams struct {
	Email     string
	Username  string
	FirstName string
	LastName  string
	Role      string
	Digest    string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (UserInfo, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Role,
		arg.Digest,
	)
	var i UserInfo
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Role,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM post WHERE id = $1 AND user_id = $2
`

type DeletePostParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) DeletePost(ctx context.Context, arg DeletePostParams) error {
	_, err := q.db.Exec(ctx, deletePost, arg.ID, arg.UserID)
	return err
}

const deleteRatePost = `-- name: DeleteRatePost :exec
DELETE FROM rating WHERE post_id = $1 AND user_id = $2
`

type DeleteRatePostParams struct {
	PostID int32
	UserID int32
}

func (q *Queries) DeleteRatePost(ctx context.Context, arg DeleteRatePostParams) error {
	_, err := q.db.Exec(ctx, deleteRatePost, arg.PostID, arg.UserID)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tag WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTag, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM user_info WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, content, created_at, updated_at FROM post
`

// - Posts queries -------------------------------------
func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.Query(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsWithPagination = `-- name: GetAllPostsWithPagination :many
SELECT id, user_id, title, content, created_at, updated_at, COUNT(*) OVER() AS total_count, CEIL(COUNT(*) OVER() / $2::float) AS max_page_id, $2 AS page_size
FROM post
WHERE
    user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAllPostsWithPaginationParams struct {
	UserID int32
	Limit  float64
	Offset int64
}

type GetAllPostsWithPaginationRow struct {
	ID         int32
	UserID     int32
	Title      string
	Content    string
	CreatedAt  pgtype.Timestamp
	UpdatedAt  pgtype.Timestamp
	TotalCount int64
	MaxPageID  float64
	PageSize   pgtype.Float8
}

func (q *Queries) GetAllPostsWithPagination(ctx context.Context, arg GetAllPostsWithPaginationParams) ([]GetAllPostsWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllPostsWithPagination, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPostsWithPaginationRow
	for rows.Next() {
		var i GetAllPostsWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
			&i.MaxPageID,
			&i.PageSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTags = `-- name: GetAllTags :many

SELECT id, name, created_at, updated_at FROM tag
`

// Tag queries -------------------------------------
func (q *Queries) GetAllTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTagsWithPagination = `-- name: GetAllTagsWithPagination :many
SELECT id, name, created_at, updated_at, COUNT(*) OVER() AS total_count, CEIL(COUNT(*) OVER() / $2::float) AS max_page_id, $2 AS page_size
FROM tag
ORDER BY name
LIMIT $2 OFFSET $1
`

type GetAllTagsWithPaginationParams struct {
	Offset int64
	Limit  float64
}

type GetAllTagsWithPaginationRow struct {
	ID         int32
	Name       string
	CreatedAt  pgtype.Timestamp
	UpdatedAt  pgtype.Timestamp
	TotalCount int64
	MaxPageID  float64
	PageSize   pgtype.Float8
}

func (q *Queries) GetAllTagsWithPagination(ctx context.Context, arg GetAllTagsWithPaginationParams) ([]GetAllTagsWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllTagsWithPagination, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTagsWithPaginationRow
	for rows.Next() {
		var i GetAllTagsWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
			&i.MaxPageID,
			&i.PageSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserRatedPostsWithPagination = `-- name: GetAllUserRatedPostsWithPagination :many
SELECT
    p.id, p.user_id, p.title, p.content, p.created_at, p.updated_at,
    r.rating_value,
    COUNT(*) OVER() AS total_count,
    CEIL(COUNT(*) OVER() / $3::float) AS max_page_id,
    $3 AS page_size
FROM
    post p
JOIN
    rating r ON p.id = r.post_id
WHERE
    r.user_id = $1
ORDER BY
    p.created_at DESC
LIMIT $3 OFFSET $2
`

type GetAllUserRatedPostsWithPaginationParams struct {
	UserID int32
	Offset int64
	Limit  float64
}

type GetAllUserRatedPostsWithPaginationRow struct {
	ID          int32
	UserID      int32
	Title       string
	Content     string
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	RatingValue int32
	TotalCount  int64
	MaxPageID   float64
	PageSize    pgtype.Float8
}

func (q *Queries) GetAllUserRatedPostsWithPagination(ctx context.Context, arg GetAllUserRatedPostsWithPaginationParams) ([]GetAllUserRatedPostsWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllUserRatedPostsWithPagination, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserRatedPostsWithPaginationRow
	for rows.Next() {
		var i GetAllUserRatedPostsWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RatingValue,
			&i.TotalCount,
			&i.MaxPageID,
			&i.PageSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many

SELECT id, email, username, first_name, last_name, role, password, created_at, updated_at FROM user_info
`

// - User Info queries -------------------------------------
func (q *Queries) GetAllUsers(ctx context.Context) ([]UserInfo, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserInfo
	for rows.Next() {
		var i UserInfo
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.Role,
			&i.Password,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersWithPagination = `-- name: GetAllUsersWithPagination :many
SELECT id, email, username, first_name, last_name, role, password, created_at, updated_at, COUNT(*) OVER() AS total_count, CEIL(COUNT(*) OVER() / $2::float) AS max_page_id, $2 AS page_size
FROM user_info 
ORDER BY username 
LIMIT $2 OFFSET $1
`

type GetAllUsersWithPaginationParams struct {
	Offset int64
	Limit  float64
}

type GetAllUsersWithPaginationRow struct {
	ID         int32
	Email      string
	Username   string
	FirstName  string
	LastName   string
	Role       string
	Password   string
	CreatedAt  pgtype.Timestamp
	UpdatedAt  pgtype.Timestamp
	TotalCount int64
	MaxPageID  float64
	PageSize   pgtype.Float8
}

func (q *Queries) GetAllUsersWithPagination(ctx context.Context, arg GetAllUsersWithPaginationParams) ([]GetAllUsersWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersWithPagination, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersWithPaginationRow
	for rows.Next() {
		var i GetAllUsersWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.Role,
			&i.Password,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
			&i.MaxPageID,
			&i.PageSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByID = `-- name: GetPostByID :one
SELECT id, user_id, title, content, created_at, updated_at FROM post WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPostByID(ctx context.Context, id int32) (Post, error) {
	row := q.db.QueryRow(ctx, getPostByID, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name, created_at, updated_at FROM tag WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTagByID(ctx context.Context, id int32) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagByID, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTopPostsInPeriodWithPagination = `-- name: GetTopPostsInPeriodWithPagination :many
SELECT
    p.id, p.user_id, p.title, p.content, p.created_at, p.updated_at,
    prs.total_rating,
    COUNT(*) OVER() AS total_count,
    CEIL(COUNT(*) OVER() / $2::float) AS max_page_id,
    $2 AS page_size
FROM
    post p
JOIN
    post_rating_summary prs ON p.id = prs.post_id
WHERE
    p.created_at >= NOW() - $1::interval
ORDER BY
    prs.total_rating DESC
LIMIT $2 OFFSET $3
`

type GetTopPostsInPeriodWithPaginationParams struct {
	Column1 pgtype.Interval
	Limit   float64
	Offset  int64
}

type GetTopPostsInPeriodWithPaginationRow struct {
	ID          int32
	UserID      int32
	Title       string
	Content     string
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	TotalRating pgtype.Int4
	TotalCount  int64
	MaxPageID   float64
	PageSize    pgtype.Float8
}

func (q *Queries) GetTopPostsInPeriodWithPagination(ctx context.Context, arg GetTopPostsInPeriodWithPaginationParams) ([]GetTopPostsInPeriodWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, getTopPostsInPeriodWithPagination, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopPostsInPeriodWithPaginationRow
	for rows.Next() {
		var i GetTopPostsInPeriodWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalRating,
			&i.TotalCount,
			&i.MaxPageID,
			&i.PageSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, username, first_name, last_name, role, password, created_at, updated_at FROM user_info WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (UserInfo, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i UserInfo
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Role,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :exec
UPDATE post
SET
    title = COALESCE($2, title),
    content = COALESCE($3, content)
WHERE
    id = $1
    AND user_id = $4
`

type UpdatePostParams struct {
	ID      int32
	Title   string
	Content string
	UserID  int32
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) error {
	_, err := q.db.Exec(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Content,
		arg.UserID,
	)
	return err
}

const updateTag = `-- name: UpdateTag :exec
UPDATE tag
SET
    name = COALESCE($2, name)
WHERE
    id = $1
`

type UpdateTagParams struct {
	ID   int32
	Name string
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) error {
	_, err := q.db.Exec(ctx, updateTag, arg.ID, arg.Name)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE user_info
SET
    email = COALESCE($2, email),
    username = COALESCE($3, username),
    first_name = COALESCE($4, first_name),
    last_name = COALESCE($5, last_name),
    password = COALESCE(encode(digest($6, 'sha256'), 'hex'), password)
WHERE
    id = $1
`

type UpdateUserParams struct {
	ID        int32
	Email     string
	Username  string
	FirstName string
	LastName  string
	Digest    string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Email,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Digest,
	)
	return err
}

const upsertRatePost = `-- name: UpsertRatePost :exec
INSERT INTO
    rating (
        user_id,
        post_id,
        rating_value
    )
VALUES ($1, $2, $3) ON CONFLICT (post_id, user_id) DO
UPDATE
SET
    rating_value = EXCLUDED.rating_value
`

type UpsertRatePostParams struct {
	UserID      int32
	PostID      int32
	RatingValue int32
}

func (q *Queries) UpsertRatePost(ctx context.Context, arg UpsertRatePostParams) error {
	_, err := q.db.Exec(ctx, upsertRatePost, arg.UserID, arg.PostID, arg.RatingValue)
	return err
}
